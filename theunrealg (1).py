# -*- coding: utf-8 -*-
"""TheUnrealG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lEPnrS5alBbkSAm6L1K9sJO5Qd0bsU8e
"""

#GST Reconciliation Agent Using DONUT
!pip install transformers
!pip install torch torchvision
!pip install datasets
!pip install Pillow
!pip install matplotlib
!pip install pandas
!pip install numpy
!pip install opencv-python
!pip install reportlab
!pip install faker
!pip install timm
!pip install sentencepiece
!pip install accelerate

import torch
import torch.nn as nn
from transformers import (
    DonutProcessor,
    VisionEncoderDecoderModel,
    VisionEncoderDecoderConfig,
    AutoTokenizer,
    TrainingArguments,
    Trainer
)
from PIL import Image, ImageDraw, ImageFont
import pandas as pd
import numpy as np
import json
import random
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import cv2
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from faker import Faker
import os
from datasets import Dataset
from torch.utils.data import DataLoader
import warnings
warnings.filterwarnings('ignore')

"""Generator"""

import subprocess
import sys

def install_packages():
    packages = [
        'Pillow',
        'faker'
    ]

    for package in packages:
        print(f"Installing {package}...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])

    print("All packages installed successfully!")

install_packages()


import random
import os
from datetime import datetime, timedelta
from PIL import Image, ImageDraw, ImageFont
from faker import Faker

class SyntheticInvoiceGenerator:
    def __init__(self):
        self.fake = Faker('en_IN')  # Indian locale for realistic data
        self.gst_rates = [0, 5, 12, 18, 28]  # Common GST rates in India

        # Product categories with typical descriptions
        self.product_categories = {
            'Electronics': ['Laptop', 'Mobile Phone', 'Television', 'Camera', 'Headphones', 'Tablet', 'Speaker', 'Monitor'],
            'Clothing': ['Shirt', 'Jeans', 'Dress', 'Jacket', 'T-Shirt', 'Saree', 'Kurta', 'Trousers'],
            'Food': ['Rice', 'Wheat', 'Sugar', 'Oil', 'Spices', 'Pulses', 'Tea', 'Coffee'],
            'Furniture': ['Chair', 'Table', 'Sofa', 'Bed', 'Wardrobe', 'Desk', 'Cabinet', 'Bookshelf'],
            'Cosmetics': ['Lipstick', 'Foundation', 'Shampoo', 'Cream', 'Perfume', 'Lotion', 'Soap', 'Face Wash'],
            'Automobile': ['Car', 'Bike', 'Scooter', 'Spare Parts', 'Tyres', 'Battery', 'Engine Oil', 'Accessories'],
            'Books': ['Novel', 'Textbook', 'Magazine', 'Journal', 'Dictionary', 'Comics', 'Biography', 'Manual'],
            'Sports': ['Cricket Bat', 'Football', 'Tennis Racket', 'Basketball', 'Badminton Set', 'Gym Equipment', 'Sports Shoes']
        }

    def generate_company_data(self):
        """Generate realistic company information"""
        return {
            'name': self.fake.company(),
            'address': self.fake.address(),
            'gstin': self.generate_gstin(),
            'email': self.fake.email(),
            'phone': self.fake.phone_number()
        }

    def generate_gstin(self):
        """Generate realistic GSTIN format"""
        state_code = random.randint(1, 37)
        pan = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=10))
        entity_code = random.choice(['1', '2', '4'])
        check_digit = random.choice('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
        return f"{state_code:02d}{pan}{entity_code}Z{check_digit}"

    def generate_invoice_items(self, num_items=None):
        """Generate invoice line items"""
        if num_items is None:
            num_items = random.randint(1, 8)

        items = []

        for _ in range(num_items):
            category = random.choice(list(self.product_categories.keys()))
            product = random.choice(self.product_categories[category])

            brands = ['Premium', 'Standard', 'Deluxe', 'Basic', 'Pro', 'Elite', 'Classic', 'Modern']
            description = f"{random.choice(brands)} {product}"

            gst_rate = random.choice(self.gst_rates)

            if category in ['Electronics', 'Automobile']:
                quantity = random.randint(1, 3)
                rate = round(random.uniform(5000, 50000), 2)
            elif category in ['Food']:
                quantity = random.randint(10, 100)
                rate = round(random.uniform(50, 200), 2)
            elif category in ['Clothing', 'Cosmetics']:
                quantity = random.randint(5, 50)
                rate = round(random.uniform(200, 2000), 2)
            elif category in ['Books']:
                quantity = random.randint(1, 10)
                rate = round(random.uniform(100, 800), 2)
            else:
                quantity = random.randint(1, 20)
                rate = round(random.uniform(100, 5000), 2)

            base_amount = round(quantity * rate, 2)
            gst_amount = round(base_amount * gst_rate / 100, 2)

            item = {
                'description': description,
                'category': category,
                'quantity': quantity,
                'rate': rate,
                'amount': base_amount,
                'gst_rate': gst_rate,
                'gst_amount': gst_amount,
                'total_amount': base_amount + gst_amount,
                'unit': self.get_unit_for_category(category)
            }
            items.append(item)

        return items

    def get_unit_for_category(self, category):
        """Get appropriate unit of measurement for category"""
        unit_mapping = {
            'Electronics': random.choice(['PCS', 'NOS', 'SET']),
            'Clothing': random.choice(['PCS', 'NOS']),
            'Food': random.choice(['KG', 'LTR', 'PCS', 'Quintal']),
            'Furniture': random.choice(['PCS', 'NOS', 'SET']),
            'Cosmetics': random.choice(['PCS', 'ML', 'GM']),
            'Automobile': random.choice(['NOS', 'PCS']),
            'Books': random.choice(['PCS', 'NOS']),
            'Sports': random.choice(['PCS', 'NOS', 'SET'])
        }
        return unit_mapping.get(category, 'PCS')

    def introduce_discrepancies(self, original_items, discrepancy_probability=0.3):
        """Introduce minimal discrepancies in items for buyer/seller mismatch scenarios"""
        modified_items = []

        for item in original_items:
            new_item = item.copy()

            # Randomly introduce discrepancies
            if random.random() < discrepancy_probability:
                discrepancy_type = random.choice(['quantity', 'rate', 'gst_rate', 'description'])

                if discrepancy_type == 'quantity':
                    # Small quantity difference (±1-2 units)
                    variance = random.randint(-2, 2)
                    new_item['quantity'] = max(1, item['quantity'] + variance)

                elif discrepancy_type == 'rate':
                    # Small rate difference (±5%)
                    variance = random.uniform(-0.05, 0.05)
                    new_item['rate'] = round(item['rate'] * (1 + variance), 2)

                elif discrepancy_type == 'gst_rate':
                    # Different GST rate (common mistake)
                    available_rates = [rate for rate in self.gst_rates if rate != item['gst_rate']]
                    if available_rates:
                        new_item['gst_rate'] = random.choice(available_rates)

                elif discrepancy_type == 'description':
                    # Minor description change
                    brands = ['Premium', 'Standard', 'Deluxe', 'Basic', 'Pro', 'Elite', 'Classic', 'Modern']
                    product_name = item['description'].split(' ', 1)[1] if ' ' in item['description'] else item['description']
                    new_item['description'] = f"{random.choice(brands)} {product_name}"

                # Recalculate amounts based on changes
                new_item['amount'] = round(new_item['quantity'] * new_item['rate'], 2)
                new_item['gst_amount'] = round(new_item['amount'] * new_item['gst_rate'] / 100, 2)
                new_item['total_amount'] = new_item['amount'] + new_item['gst_amount']

            modified_items.append(new_item)

        return modified_items

    def generate_paired_invoices(self):
        """Generate a pair of invoices - one for buyer, one for seller with same transaction"""
        # Generate base data
        supplier = self.generate_company_data()
        buyer = self.generate_company_data()
        items = self.generate_invoice_items()

        # Generate base invoice number and date
        base_invoice_num = random.randint(1000, 9999)
        invoice_date = self.fake.date_between(start_date='-1y', end_date='today')

        # Calculate totals for original items
        subtotal = sum(item['amount'] for item in items)
        total_gst = sum(item['gst_amount'] for item in items)
        grand_total = subtotal + total_gst

        # Create seller invoice (original data)
        seller_invoice = {
            'invoice_number': f"SELL-{base_invoice_num}",
            'invoice_date': invoice_date.strftime('%d/%m/%Y'),
            'supplier': supplier,
            'buyer': buyer,
            'items': items,
            'subtotal': round(subtotal, 2),
            'total_gst': round(total_gst, 2),
            'grand_total': round(grand_total, 2),
            'invoice_type': 'SELLER_INVOICE'
        }

        # Create buyer invoice with potential discrepancies
        buyer_items = self.introduce_discrepancies(items, discrepancy_probability=0.4)

        # Recalculate totals for buyer items
        buyer_subtotal = sum(item['amount'] for item in buyer_items)
        buyer_total_gst = sum(item['gst_amount'] for item in buyer_items)
        buyer_grand_total = buyer_subtotal + buyer_total_gst

        buyer_invoice = {
            'invoice_number': f"BUY-{base_invoice_num}",
            'invoice_date': invoice_date.strftime('%d/%m/%Y'),
            'supplier': supplier,
            'buyer': buyer,
            'items': buyer_items,
            'subtotal': round(buyer_subtotal, 2),
            'total_gst': round(buyer_total_gst, 2),
            'grand_total': round(buyer_grand_total, 2),
            'invoice_type': 'BUYER_INVOICE'
        }

        return seller_invoice, buyer_invoice

class InvoiceImageGenerator:
    def __init__(self, width=800, height=1200):
        self.width = width
        self.height = height

    def create_invoice_image(self, invoice_data):
        """Create a synthetic invoice image"""
        img = Image.new('RGB', (self.width, self.height), 'white')
        draw = ImageDraw.Draw(img)

        try:
            title_font = ImageFont.load_default()
            header_font = ImageFont.load_default()
            normal_font = ImageFont.load_default()
        except:
            title_font = ImageFont.load_default()
            header_font = ImageFont.load_default()
            normal_font = ImageFont.load_default()

        y_pos = 30

        # Title with invoice type
        title_color = 'blue' if invoice_data['invoice_type'] == 'SELLER_INVOICE' else 'green'
        draw.text((50, y_pos), f"GST INVOICE - {invoice_data['invoice_type']}", fill=title_color, font=title_font)
        y_pos += 40

        # Invoice details
        draw.text((50, y_pos), f"Invoice No : {invoice_data['invoice_number']}", fill='black', font=header_font)
        draw.text((400, y_pos), f"Date : {invoice_data['invoice_date']}", fill='black', font=header_font)
        y_pos += 30

        # Supplier info
        draw.text((50, y_pos), "Supplier Details :", fill='black', font=header_font)
        y_pos += 20
        draw.text((50, y_pos), invoice_data['supplier']['name'], fill='black', font=normal_font)
        y_pos += 15
        draw.text((50, y_pos), f"GSTIN : {invoice_data['supplier']['gstin']}", fill='black', font=normal_font)
        y_pos += 15
        # Truncate address for display
        address_lines = invoice_data['supplier']['address'].split('\n')[:2]
        for line in address_lines:
            draw.text((50, y_pos), line[:50], fill='black', font=normal_font)
            y_pos += 15

        y_pos += 20

        # Buyer info
        draw.text((50, y_pos), "Buyer Details :", fill='black', font=header_font)
        y_pos += 20
        draw.text((50, y_pos), invoice_data['buyer']['name'], fill='black', font=normal_font)
        y_pos += 15
        draw.text((50, y_pos), f"GSTIN : {invoice_data['buyer']['gstin']}", fill='black', font=normal_font)
        y_pos += 30

        # Items header
        draw.text((50, y_pos), "Description", fill='black', font=header_font)
        draw.text((250, y_pos), "Qty", fill='black', font=header_font)
        draw.text((290, y_pos), "Unit", fill='black', font=header_font)
        draw.text((330, y_pos), "Rate", fill='black', font=header_font)
        draw.text((390, y_pos), "Amount", fill='black', font=header_font)
        draw.text((460, y_pos), "GST%", fill='black', font=header_font)
        draw.text((500, y_pos), "GST Amt", fill='black', font=header_font)
        draw.text((570, y_pos), "Total", fill='black', font=header_font)
        y_pos += 25

        # Draw line
        draw.line([(50, y_pos), (650, y_pos)], fill='black', width=1)
        y_pos += 10

        # Items
        for item in invoice_data['items']:
            desc = item['description'][:25] + "..." if len(item['description']) > 25 else item['description']
            draw.text((50, y_pos), desc, fill='black', font=normal_font)
            draw.text((250, y_pos), str(item['quantity']), fill='black', font=normal_font)
            draw.text((290, y_pos), item['unit'], fill='black', font=normal_font)
            draw.text((330, y_pos), str(item['rate']), fill='black', font=normal_font)
            draw.text((390, y_pos), str(item['amount']), fill='black', font=normal_font)
            draw.text((460, y_pos), f"{item['gst_rate']}%", fill='black', font=normal_font)
            draw.text((500, y_pos), str(item['gst_amount']), fill='black', font=normal_font)
            draw.text((570, y_pos), str(item['total_amount']), fill='black', font=normal_font)
            y_pos += 20

        y_pos += 20

        # Totals
        draw.line([(330, y_pos), (650, y_pos)], fill='black', width=1)
        y_pos += 10
        draw.text((430, y_pos), f"Subtotal: Rs. {invoice_data['subtotal']}", fill='black', font=normal_font)
        y_pos += 20
        draw.text((430, y_pos), f"Total GST: Rs. {invoice_data['total_gst']}", fill='black', font=normal_font)
        y_pos += 20
        draw.text((430, y_pos), f"Grand Total: Rs. {invoice_data['grand_total']}", fill='black', font=header_font)

        return img

def generate_paired_invoice_samples(num_pairs=5):
    """Generate paired invoices (buyer and seller) for training"""
    generator = SyntheticInvoiceGenerator()
    image_generator = InvoiceImageGenerator()

    # Create directories
    os.makedirs('seller_invoices', exist_ok=True)
    os.makedirs('buyer_invoices', exist_ok=True)

    print(f"Generating {num_pairs} pairs of invoices (seller + buyer)...")

    for i in range(num_pairs):
        print(f"Generating invoice pair {i+1}/{num_pairs}")

        # Generate paired invoices
        seller_invoice, buyer_invoice = generator.generate_paired_invoices()

        # Create seller invoice image
        seller_image = image_generator.create_invoice_image(seller_invoice)
        seller_filename = f"seller_invoices/seller_invoice_{i+1}.png"
        seller_image.save(seller_filename)

        # Create buyer invoice image
        buyer_image = image_generator.create_invoice_image(buyer_invoice)
        buyer_filename = f"buyer_invoices/buyer_invoice_{i+1}.png"
        buyer_image.save(buyer_filename)

        print(f"✅ Saved pair: {seller_filename} and {buyer_filename}")

        # Print summary of discrepancies for this pair
        print(f"   📊 Seller total: Rs.{seller_invoice['grand_total']}")
        print(f"   📊 Buyer total: Rs.{buyer_invoice['grand_total']}")
        difference = abs(seller_invoice['grand_total'] - buyer_invoice['grand_total'])
        if difference > 0:
            print(f"   ⚠️  Amount difference: Rs.{difference}")
        else:
            print(f"   ✅ Perfect match")

    print("\n🎉 All invoice pairs generated successfully!")
    print("📁 Check 'seller_invoices' folder for seller invoice images")
    print("📁 Check 'buyer_invoices' folder for buyer invoice images")

    # List generated files
    print("\n📋 Generated files:")
    if os.path.exists('seller_invoices'):
        for file in sorted(os.listdir('seller_invoices')):
            print(f"  📄 seller_invoices/{file}")
    if os.path.exists('buyer_invoices'):
        for file in sorted(os.listdir('buyer_invoices')):
            print(f"  📄 buyer_invoices/{file}")

# Run the generator
print("🚀 Starting Paired Invoice Generator...")
generate_paired_invoice_samples(3)  # Change this number to generate more pairs

try:
    from IPython.display import Image as IPImage, display
    print("\n🖼️ Displaying first generated invoice pair:")
    print("Seller Invoice:")
    display(IPImage('seller_invoices/seller_invoice_1.png'))
    print("Buyer Invoice:")
    display(IPImage('buyer_invoices/buyer_invoice_1.png'))
except:
    print("Note: Could not display image preview, but files are generated successfully!")

print("\n✨ Paired invoice generation complete! You can download the files from the file browser on the left.")

import subprocess
import sys
import os
import re
from typing import Dict, List, Tuple, Any
import json
from datetime import datetime

def install_packages():
    """Install required packages with error handling"""
    packages = [
        'opencv-python',
        'numpy',
        'Pillow',
        'pandas'
    ]

    # Install basic packages first
    for package in packages:
        print(f"Installing {package}...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        except subprocess.CalledProcessError as e:
            print(f"Warning: Could not install {package}: {e}")

    # Try to install PaddlePaddle (CPU version first, more stable)
    print("Installing PaddlePaddle...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "paddlepaddle"])
        print("✅ PaddlePaddle CPU version installed successfully!")
    except subprocess.CalledProcessError:
        print("❌ Failed to install PaddlePaddle CPU version")
        # Try alternative approach
        try:
            print("Trying alternative PaddlePaddle installation...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", "paddlepaddle==2.5.2"])
        except subprocess.CalledProcessError as e:
            print(f"❌ PaddlePaddle installation failed: {e}")
            print("⚠️  You may need to install PaddlePaddle manually")
            return False

    # Install PaddleOCR
    print("Installing PaddleOCR...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "paddleocr"])
        print("✅ PaddleOCR installed successfully!")
    except subprocess.CalledProcessError as e:
        print(f"❌ PaddleOCR installation failed: {e}")
        return False

    print("🎉 All packages installed successfully!")
    return True

# 🔧 UNCOMMENT THE LINE BELOW TO INSTALL PACKAGES (FIRST RUN ONLY)
install_packages()

# Import statements with error handling
try:
    import cv2
    import numpy as np
    from paddleocr import PaddleOCR
    print("✅ All imports successful!")
except ImportError as e:
    print(f"❌ Import error: {e}")
    print("🔧 Please run install_packages() first by uncommenting the line above")
    print("   or manually install: pip install paddlepaddle paddleocr opencv-python")

import pandas as pd
from PIL import Image
import difflib

class InvoiceOCRExtractor:
    def __init__(self):
        """Initialize PaddleOCR with English language support"""
        self.ocr = PaddleOCR(use_angle_cls=True, lang='en')

    def extract_text_from_image(self, image_path: str) -> List[Tuple[str, float]]:
        """Extract text from invoice image using PaddleOCR"""
        try:
            result = self.ocr.ocr(image_path, cls=True)

            text_data = []
            if result and result[0]:
                for line in result[0]:
                    text = line[1][0]  # Extracted text
                    confidence = line[1][1]  # Confidence score
                    text_data.append((text, confidence))

            return text_data
        except Exception as e:
            print(f"Error extracting text from {image_path}: {e}")
            return []

class InvoiceDataParser:
    def __init__(self):
        self.gstin_pattern = r'\b\d{2}[A-Z]{5}\d{4}[A-Z]{1}[A-Z\d]{1}[Z]{1}[A-Z\d]{1}\b'
        self.amount_pattern = r'(?:Rs\.?\s*)?(\d+(?:,\d{3})*(?:\.\d{2})?)'
        self.invoice_num_pattern = r'(?:Invoice\s*No\.?\s*:?\s*|INV\s*[-#]?\s*)([A-Z0-9\-]+)'
        self.date_pattern = r'(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})'

    def parse_invoice_data(self, text_data: List[Tuple[str, float]]) -> Dict[str, Any]:
        """Parse extracted text to structured invoice data"""
        full_text = " ".join([text for text, conf in text_data if conf > 0.5])

        invoice_data = {
            'invoice_number': self._extract_invoice_number(full_text),
            'invoice_date': self._extract_date(full_text),
            'supplier_gstin': None,
            'buyer_gstin': None,
            'items': [],
            'subtotal': 0.0,
            'total_gst': 0.0,
            'grand_total': 0.0,
            'invoice_type': self._determine_invoice_type(full_text)
        }

        # Extract GSTIN numbers
        gstins = self._extract_gstins(full_text)
        if len(gstins) >= 2:
            invoice_data['supplier_gstin'] = gstins[0]
            invoice_data['buyer_gstin'] = gstins[1]
        elif len(gstins) == 1:
            invoice_data['supplier_gstin'] = gstins[0]

        # Extract amounts
        amounts = self._extract_amounts(full_text)
        if amounts:
            # Assume last three amounts are subtotal, GST, and grand total
            if len(amounts) >= 3:
                invoice_data['subtotal'] = amounts[-3]
                invoice_data['total_gst'] = amounts[-2]
                invoice_data['grand_total'] = amounts[-1]
            elif len(amounts) >= 1:
                invoice_data['grand_total'] = amounts[-1]

        # Extract line items
        invoice_data['items'] = self._extract_line_items(text_data)

        return invoice_data

    def _extract_invoice_number(self, text: str) -> str:
        """Extract invoice number from text"""
        match = re.search(self.invoice_num_pattern, text, re.IGNORECASE)
        return match.group(1) if match else "Unknown"

    def _extract_date(self, text: str) -> str:
        """Extract date from text"""
        match = re.search(self.date_pattern, text)
        return match.group(1) if match else "Unknown"

    def _extract_gstins(self, text: str) -> List[str]:
        """Extract GSTIN numbers from text"""
        return re.findall(self.gstin_pattern, text)

    def _extract_amounts(self, text: str) -> List[float]:
        """Extract monetary amounts from text"""
        matches = re.findall(self.amount_pattern, text)
        amounts = []
        for match in matches:
            try:
                # Remove commas and convert to float
                amount = float(match.replace(',', ''))
                amounts.append(amount)
            except ValueError:
                continue
        return amounts

    def _determine_invoice_type(self, text: str) -> str:
        """Determine if invoice is seller or buyer type"""
        if 'SELLER' in text.upper():
            return 'SELLER_INVOICE'
        elif 'BUYER' in text.upper() or 'BUY' in text.upper():
            return 'BUYER_INVOICE'
        else:
            return 'UNKNOWN'

    def _extract_line_items(self, text_data: List[Tuple[str, float]]) -> List[Dict[str, Any]]:
        """Extract line items from invoice (simplified implementation)"""
        items = []

        # Look for lines with multiple numbers (likely item lines)
        for text, conf in text_data:
            if conf > 0.6:
                # Check if line contains multiple numbers (quantity, rate, amount pattern)
                numbers = re.findall(r'\d+(?:\.\d{2})?', text)
                if len(numbers) >= 3:  # Likely an item line
                    try:
                        item = {
                            'description': re.sub(r'\d+(?:\.\d{2})?', '', text).strip(),
                            'amount': float(numbers[-1]) if numbers else 0.0
                        }
                        if item['description']:  # Only add if description exists
                            items.append(item)
                    except (ValueError, IndexError):
                        continue

        return items[:10]  # Limit to first 10 items to avoid noise

class GST_Reconciliation_Engine:
    def __init__(self):
        self.ocr_extractor = InvoiceOCRExtractor()
        self.parser = InvoiceDataParser()

    def process_invoice_pair(self, seller_image_path: str, buyer_image_path: str) -> Dict[str, Any]:
        """Process a pair of invoices and generate reconciliation report"""

        print(f"Processing seller invoice: {seller_image_path}")
        seller_text = self.ocr_extractor.extract_text_from_image(seller_image_path)
        seller_data = self.parser.parse_invoice_data(seller_text)

        print(f"Processing buyer invoice: {buyer_image_path}")
        buyer_text = self.ocr_extractor.extract_text_from_image(buyer_image_path)
        buyer_data = self.parser.parse_invoice_data(buyer_text)

        # Generate reconciliation report
        reconciliation_report = self._compare_invoices(seller_data, buyer_data)

        return {
            'seller_data': seller_data,
            'buyer_data': buyer_data,
            'reconciliation_report': reconciliation_report,
            'processing_timestamp': datetime.now().isoformat()
        }

    def _compare_invoices(self, seller_data: Dict, buyer_data: Dict) -> Dict[str, Any]:
        """Compare seller and buyer invoices for reconciliation"""

        report = {
            'status': 'PROCESSED',
            'matches': [],
            'mismatches': [],
            'summary': {
                'total_matches': 0,
                'total_mismatches': 0,
                'match_percentage': 0.0,
                'critical_mismatches': 0
            }
        }

        # Compare basic details
        comparisons = [
            ('Invoice Date', seller_data['invoice_date'], buyer_data['invoice_date']),
            ('Supplier GSTIN', seller_data['supplier_gstin'], buyer_data['supplier_gstin']),
            ('Buyer GSTIN', seller_data['buyer_gstin'], buyer_data['buyer_gstin']),
            ('Subtotal', seller_data['subtotal'], buyer_data['subtotal']),
            ('Total GST', seller_data['total_gst'], buyer_data['total_gst']),
            ('Grand Total', seller_data['grand_total'], buyer_data['grand_total'])
        ]

        for field_name, seller_val, buyer_val in comparisons:
            if self._values_match(seller_val, buyer_val):
                report['matches'].append({
                    'field': field_name,
                    'seller_value': seller_val,
                    'buyer_value': buyer_val,
                    'status': 'MATCH'
                })
            else:
                is_critical = field_name in ['Grand Total', 'Total GST', 'Supplier GSTIN']
                report['mismatches'].append({
                    'field': field_name,
                    'seller_value': seller_val,
                    'buyer_value': buyer_val,
                    'status': 'MISMATCH',
                    'critical': is_critical,
                    'difference': self._calculate_difference(seller_val, buyer_val)
                })
                if is_critical:
                    report['summary']['critical_mismatches'] += 1

        # Compare line items
        item_comparison = self._compare_line_items(seller_data['items'], buyer_data['items'])
        report['item_comparison'] = item_comparison

        # Update summary
        report['summary']['total_matches'] = len(report['matches'])
        report['summary']['total_mismatches'] = len(report['mismatches'])
        total_comparisons = report['summary']['total_matches'] + report['summary']['total_mismatches']

        if total_comparisons > 0:
            report['summary']['match_percentage'] = round(
                (report['summary']['total_matches'] / total_comparisons) * 100, 2
            )

        return report

    def _values_match(self, val1: Any, val2: Any, tolerance: float = 0.01) -> bool:
        """Check if two values match with tolerance for floating point numbers"""
        if val1 is None or val2 is None:
            return val1 == val2

        if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):
            return abs(val1 - val2) <= tolerance

        return str(val1).strip().upper() == str(val2).strip().upper()

    def _calculate_difference(self, val1: Any, val2: Any) -> str:
        """Calculate difference between two values"""
        if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):
            diff = abs(val1 - val2)
            return f"₹{diff:.2f}"

        if isinstance(val1, str) and isinstance(val2, str):
            similarity = difflib.SequenceMatcher(None, val1, val2).ratio()
            return f"{similarity*100:.1f}% similar"

        return "Different types"

    def _compare_line_items(self, seller_items: List[Dict], buyer_items: List[Dict]) -> Dict[str, Any]:
        """Compare line items between seller and buyer invoices"""
        return {
            'seller_item_count': len(seller_items),
            'buyer_item_count': len(buyer_items),
            'count_match': len(seller_items) == len(buyer_items),
            'item_details': {
                'seller_items': seller_items[:5],  # Show first 5 items
                'buyer_items': buyer_items[:5]     # Show first 5 items
            }
        }

class ReportGenerator:
    def __init__(self):
        pass

    def generate_console_report(self, reconciliation_result: Dict[str, Any]) -> None:
        """Generate a detailed console report"""

        print("\n" + "="*80)
        print("GST INVOICE RECONCILIATION REPORT")
        print("="*80)

        # Processing info
        print(f"📅 Report Generated: {reconciliation_result['processing_timestamp']}")
        print(f"🔍 Status: {reconciliation_result['reconciliation_report']['status']}")

        # Summary
        summary = reconciliation_result['reconciliation_report']['summary']
        print(f"\n📊 SUMMARY:")
        print(f"   ✅ Total Matches: {summary['total_matches']}")
        print(f"   ❌ Total Mismatches: {summary['total_mismatches']}")
        print(f"   🎯 Match Percentage: {summary['match_percentage']}%")
        print(f"   🚨 Critical Mismatches: {summary['critical_mismatches']}")

        # Matches
        if reconciliation_result['reconciliation_report']['matches']:
            print(f"\n✅ MATCHES ({len(reconciliation_result['reconciliation_report']['matches'])}):")
            for match in reconciliation_result['reconciliation_report']['matches']:
                print(f"   📋 {match['field']}: {match['seller_value']}")

        # Mismatches
        if reconciliation_result['reconciliation_report']['mismatches']:
            print(f"\n❌ MISMATCHES ({len(reconciliation_result['reconciliation_report']['mismatches'])}):")
            for mismatch in reconciliation_result['reconciliation_report']['mismatches']:
                critical_flag = "🚨" if mismatch.get('critical', False) else "⚠️"
                print(f"   {critical_flag} {mismatch['field']}:")
                print(f"      Seller: {mismatch['seller_value']}")
                print(f"      Buyer:  {mismatch['buyer_value']}")
                print(f"      Difference: {mismatch['difference']}")

        # Item comparison
        item_comp = reconciliation_result['reconciliation_report']['item_comparison']
        print(f"\n📦 LINE ITEMS COMPARISON:")
        print(f"   Seller Items: {item_comp['seller_item_count']}")
        print(f"   Buyer Items:  {item_comp['buyer_item_count']}")
        print(f"   Count Match:  {'✅' if item_comp['count_match'] else '❌'}")

        # Invoice details
        print(f"\n📄 SELLER INVOICE DETAILS:")
        seller = reconciliation_result['seller_data']
        print(f"   Invoice No: {seller['invoice_number']}")
        print(f"   Date: {seller['invoice_date']}")
        print(f"   Type: {seller['invoice_type']}")
        print(f"   Grand Total: ₹{seller['grand_total']}")

        print(f"\n📄 BUYER INVOICE DETAILS:")
        buyer = reconciliation_result['buyer_data']
        print(f"   Invoice No: {buyer['invoice_number']}")
        print(f"   Date: {buyer['invoice_date']}")
        print(f"   Type: {buyer['invoice_type']}")
        print(f"   Grand Total: ₹{buyer['grand_total']}")

        print("\n" + "="*80)

        # Recommendation
        if summary['critical_mismatches'] > 0:
            print("🚨 RECOMMENDATION: Critical mismatches found! Manual verification required.")
        elif summary['match_percentage'] >= 95:
            print("✅ RECOMMENDATION: High match rate. Invoices appear to be in sync.")
        elif summary['match_percentage'] >= 80:
            print("⚠️  RECOMMENDATION: Good match rate but some discrepancies. Review recommended.")
        else:
            print("❌ RECOMMENDATION: Low match rate. Detailed investigation required.")

        print("="*80)

def main():
    """Main function to run GST reconciliation"""

    # ==========================================================================
    # 🔧 CONFIGURATION: UPDATE THESE PATHS TO YOUR INVOICE IMAGES
    # ==========================================================================

    # 📁 MANUAL INPUT: Update these paths to your invoice image files
    # 👇 CHANGE THESE LINES TO POINT TO YOUR ACTUAL INVOICE FILES 👇
    SELLER_INVOICE_PATH = '/content/seller_invoices/seller_invoice_1.png' # 👈 UPDATE THIS PATH
    BUYER_INVOICE_PATH = '/content/buyer_invoices/buyer_invoice_2.png' # 👈 UPDATE THIS PATH
    # 👆 CHANGE THESE LINES TO POINT TO YOUR ACTUAL INVOICE FILES 👆

    # ==========================================================================

    print("🚀 Starting GST Invoice Reconciliation System...")

    # Check if files exist
    if not os.path.exists(SELLER_INVOICE_PATH):
        print(f"❌ Error: Seller invoice file not found: {SELLER_INVOICE_PATH}")
        print("   Please update SELLER_INVOICE_PATH with correct file path")
        return

    if not os.path.exists(BUYER_INVOICE_PATH):
        print(f"❌ Error: Buyer invoice file not found: {BUYER_INVOICE_PATH}")
        print("   Please update BUYER_INVOICE_PATH with correct file path")
        return

    # Initialize reconciliation engine
    reconciliation_engine = GST_Reconciliation_Engine()
    report_generator = ReportGenerator()

    try:
        # Process invoice pair
        print(f"\n🔄 Processing invoice pair...")
        print(f"   📁 Seller: {SELLER_INVOICE_PATH}")
        print(f"   📁 Buyer:  {BUYER_INVOICE_PATH}")

        result = reconciliation_engine.process_invoice_pair(
            SELLER_INVOICE_PATH,
            BUYER_INVOICE_PATH
        )

        # Generate report
        report_generator.generate_console_report(result)

        # Save detailed report to JSON (optional)
        output_file = f"reconciliation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(output_file, 'w') as f:
            json.dump(result, f, indent=2, default=str)

        print(f"\n💾 Detailed report saved to: {output_file}")

    except Exception as e:
        print(f"❌ Error during reconciliation: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()

# =============================================================================
# 📝 USAGE INSTRUCTIONS:
# =============================================================================
"""
1. First, uncomment the install_packages() line to install required dependencies
2. Update the SELLER_INVOICE_PATH and BUYER_INVOICE_PATH variables in main()
3. Run the script: python gst_reconciliation.py
4. The system will:
   - Extract text from both invoice images using PaddleOCR
   - Parse invoice data (amounts, GSTIN, dates, etc.)
   - Compare seller vs buyer invoices
   - Generate a detailed reconciliation report
   - Save results to JSON file

🔧 MANUAL INPUT POINTS:
- Line 265-266: Update invoice image file paths
- Line 27: Uncomment to install packages (first run only)

📊 OUTPUT:
- Console report with matches/mismatches
- JSON file with detailed reconciliation data
- Recommendations based on match percentage
"""
def process_invoice_pair(self, seller_image_path: str, buyer_image_path: str) -> Dict[str, Any]:
        """Process a pair of invoices and generate reconciliation report"""

        print(f"Processing seller invoice: {seller_image_path}")
        seller_text = self.ocr_extractor.extract_text_from_image(seller_image_path)
        print("Extracted Seller Text:", seller_text) # <--- Add this line
        seller_data = self.parser.parse_invoice_data(seller_text)

        print(f"Processing buyer invoice: {buyer_image_path}")
        buyer_text = self.ocr_extractor.extract_text_from_image(buyer_image_path)
        print("Extracted Buyer Text:", buyer_text) # <--- Add this line
        buyer_data = self.parser.parse_invoice_data(buyer_text)

        # Generate reconciliation report
        reconciliation_report = self._compare_invoices(seller_data, buyer_data)

        return {
            'seller_data': seller_data,
            'buyer_data': buyer_data,
            'reconciliation_report': reconciliation_report,
            'processing_timestamp': datetime.now().isoformat()
        }

import subprocess
import sys
import os
import re
from typing import Dict, List, Tuple, Any
import json
from datetime import datetime

def install_packages():
    """Install required packages with error handling"""
    packages = [
        'opencv-python',
        'numpy',
        'Pillow',
        'pandas'
    ]

    # Install basic packages first
    for package in packages:
        print(f"Installing {package}...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
        except subprocess.CalledProcessError as e:
            print(f"Warning: Could not install {package}: {e}")

    # Try to install PaddlePaddle (CPU version first, more stable)
    print("Installing PaddlePaddle...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "paddlepaddle"])
        print("✅ PaddlePaddle CPU version installed successfully!")
    except subprocess.CalledProcessError:
        print("❌ Failed to install PaddlePaddle CPU version")
        # Try alternative approach
        try:
            print("Trying alternative PaddlePaddle installation...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", "paddlepaddle==2.5.2"])
        except subprocess.CalledProcessError as e:
            print(f"❌ PaddlePaddle installation failed: {e}")
            print("⚠️  You may need to install PaddlePaddle manually")
            return False

    # Install PaddleOCR
    print("Installing PaddleOCR...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "paddleocr"])
        print("✅ PaddleOCR installed successfully!")
    except subprocess.CalledProcessError as e:
        print(f"❌ PaddleOCR installation failed: {e}")
        return False

    print("🎉 All packages installed successfully!")
    return True

# 🔧 UNCOMMENT THE LINE BELOW TO INSTALL PACKAGES (FIRST RUN ONLY)
install_packages()

# Import statements with error handling
try:
    import cv2
    import numpy as np
    from paddleocr import PaddleOCR
    print("✅ All imports successful!")
except ImportError as e:
    print(f"❌ Import error: {e}")
    print("🔧 Please run install_packages() first by uncommenting the line above")
    print("   or manually install: pip install paddlepaddle paddleocr opencv-python")

import pandas as pd
from PIL import Image
import difflib

class InvoiceOCRExtractor:
    def __init__(self):
        """Initialize PaddleOCR with optimized settings"""
        try:
            # Initialize with better settings for invoice processing
            self.ocr = PaddleOCR(
                use_angle_cls=True,
                lang='en',  # Force CPU to avoid GPU issues
        # Reduce noise
                det_model_dir=None,
                rec_model_dir=None,
                cls_model_dir=None
            )
            print("✅ PaddleOCR initialized successfully!")
        except Exception as e:
            print(f"❌ Error initializing PaddleOCR: {e}")
            raise

    def preprocess_image(self, image_path: str) -> str:
        """Preprocess image for better OCR results"""
        try:
            # Read image
            img = cv2.imread(image_path)
            if img is None:
                raise ValueError(f"Could not read image from {image_path}")

            print(f"📸 Original image shape: {img.shape}")

            # Convert to grayscale
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

            # Apply different preprocessing techniques
            # 1. Gaussian blur to reduce noise
            blurred = cv2.GaussianBlur(gray, (1, 1), 0)

            # 2. Increase contrast using CLAHE
            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
            enhanced = clahe.apply(blurred)

            # 3. Threshold to get better text definition
            _, thresh = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

            # Save preprocessed image temporarily
            temp_path = image_path.replace('.', '_processed.')
            cv2.imwrite(temp_path, thresh)
            print(f"💾 Preprocessed image saved to: {temp_path}")

            return temp_path

        except Exception as e:
            print(f"❌ Error preprocessing image {image_path}: {e}")
            return image_path  # Return original path if preprocessing fails

    def extract_text_from_image(self, image_path: str) -> List[Tuple[str, float]]:
        """Extract text from invoice image using PaddleOCR with enhanced processing"""
        try:
            print(f"🔍 Starting OCR extraction for: {image_path}")

            # Check if file exists
            if not os.path.exists(image_path):
                print(f"❌ File not found: {image_path}")
                return []

            # Preprocess image for better OCR
            processed_path = self.preprocess_image(image_path)

            # Try OCR on both original and processed images
            text_data = []

            for attempt, img_path in enumerate([image_path, processed_path], 1):
                print(f"🔄 OCR Attempt {attempt} on: {os.path.basename(img_path)}")

                try:
                    result = self.ocr.ocr(img_path, cls=True)

                    if result and result[0]:
                        print(f"✅ OCR successful! Found {len(result[0])} text elements")

                        for line in result[0]:
                            if line and len(line) >= 2:
                                text = line[1][0] if line[1] and len(line[1]) >= 1 else ""
                                confidence = line[1][1] if line[1] and len(line[1]) >= 2 else 0.0

                                if text.strip():  # Only add non-empty text
                                    text_data.append((text.strip(), confidence))
                                    print(f"   📝 '{text.strip()}' (confidence: {confidence:.2f})")

                        if text_data:
                            break  # If we got good results, stop trying

                    else:
                        print(f"⚠️  No text detected in attempt {attempt}")

                except Exception as e:
                    print(f"❌ OCR attempt {attempt} failed: {e}")
                    continue

            # Clean up temporary file
            if processed_path != image_path and os.path.exists(processed_path):
                try:
                    os.remove(processed_path)
                except:
                    pass

            print(f"📊 Total extracted text elements: {len(text_data)}")
            return text_data

        except Exception as e:
            print(f"❌ Error extracting text from {image_path}: {e}")
            import traceback
            traceback.print_exc()
            return []

class InvoiceDataParser:
    def __init__(self):
        # Enhanced regex patterns
        self.gstin_pattern = r'\b\d{2}[A-Z]{5}\d{4}[A-Z]{1}[A-Z\d]{1}[Z]{1}[A-Z\d]{1}\b'
        self.amount_pattern = r'(?:Rs\.?\s*|₹\s*)?(\d+(?:,\d{3})*(?:\.\d{2})?)'
        self.invoice_num_patterns = [
            r'(?:Invoice\s*No\.?\s*:?\s*|INV\s*[-#]?\s*)([A-Z0-9\-/]+)',
            r'(?:Bill\s*No\.?\s*:?\s*)([A-Z0-9\-/]+)',
            r'(?:Ref\s*No\.?\s*:?\s*)([A-Z0-9\-/]+)',
            r'\b(INV[A-Z0-9\-/]+)\b',
            r'\b([A-Z]{2,}\d{3,})\b'
        ]
        self.date_patterns = [
            r'(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})',
            r'(\d{1,2}\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{2,4})',
            r'(\d{2,4}[\/\-\.]\d{1,2}[\/\-\.]\d{1,2})'
        ]

    def parse_invoice_data(self, text_data: List[Tuple[str, float]]) -> Dict[str, Any]:
        """Parse extracted text to structured invoice data with enhanced logic"""

        if not text_data:
            print("⚠️  No text data to parse!")
            return self._get_empty_invoice_data()

        # Filter high-confidence text
        high_conf_text = [text for text, conf in text_data if conf > 0.6]
        medium_conf_text = [text for text, conf in text_data if conf > 0.4]
        all_text = [text for text, conf in text_data]

        print(f"📊 Text confidence levels:")
        print(f"   High confidence (>0.6): {len(high_conf_text)} items")
        print(f"   Medium confidence (>0.4): {len(medium_conf_text)} items")
        print(f"   All text: {len(all_text)} items")

        # Use different confidence levels for different parsing
        full_text = " ".join(all_text)
        high_conf_full = " ".join(high_conf_text)

        print(f"🔍 Sample extracted text: {full_text[:200]}...")

        invoice_data = {
            'invoice_number': self._extract_invoice_number(full_text),
            'invoice_date': self._extract_date(full_text),
            'supplier_gstin': None,
            'buyer_gstin': None,
            'items': [],
            'subtotal': 0.0,
            'total_gst': 0.0,
            'grand_total': 0.0,
            'invoice_type': self._determine_invoice_type(full_text),
            'raw_text': full_text[:500] + "..." if len(full_text) > 500 else full_text
        }

        # Extract GSTIN numbers
        gstins = self._extract_gstins(full_text)
        print(f"🔢 Found GSTINs: {gstins}")
        if len(gstins) >= 2:
            invoice_data['supplier_gstin'] = gstins[0]
            invoice_data['buyer_gstin'] = gstins[1]
        elif len(gstins) == 1:
            invoice_data['supplier_gstin'] = gstins[0]

        # Extract amounts with enhanced logic
        amounts = self._extract_amounts(full_text)
        print(f"💰 Found amounts: {amounts}")

        if amounts:
            # Sort amounts to find likely totals
            sorted_amounts = sorted(amounts, reverse=True)

            # Assign amounts based on common invoice patterns
            if len(sorted_amounts) >= 3:
                invoice_data['grand_total'] = sorted_amounts[0]  # Highest amount is usually total
                invoice_data['subtotal'] = sorted_amounts[-1]    # Lower amounts might be subtotal

                # Try to find GST amount (usually between 5-28% of subtotal)
                for amt in sorted_amounts[1:-1]:
                    if invoice_data['subtotal'] > 0:
                        gst_percentage = (amt / invoice_data['subtotal']) * 100
                        if 5 <= gst_percentage <= 30:  # Reasonable GST range
                            invoice_data['total_gst'] = amt
                            break

            elif len(sorted_amounts) >= 1:
                invoice_data['grand_total'] = sorted_amounts[0]

        # Extract line items
        invoice_data['items'] = self._extract_line_items(text_data)

        print(f"📋 Parsed invoice data summary:")
        print(f"   Invoice Number: {invoice_data['invoice_number']}")
        print(f"   Date: {invoice_data['invoice_date']}")
        print(f"   Grand Total: ₹{invoice_data['grand_total']}")
        print(f"   Items found: {len(invoice_data['items'])}")

        return invoice_data

    def _get_empty_invoice_data(self):
        """Return empty invoice data structure"""
        return {
            'invoice_number': "Unknown",
            'invoice_date': "Unknown",
            'supplier_gstin': None,
            'buyer_gstin': None,
            'items': [],
            'subtotal': 0.0,
            'total_gst': 0.0,
            'grand_total': 0.0,
            'invoice_type': "UNKNOWN",
            'raw_text': ""
        }

    def _extract_invoice_number(self, text: str) -> str:
        """Extract invoice number using multiple patterns"""
        for pattern in self.invoice_num_patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                result = match.group(1).strip()
                if len(result) > 2:  # Ensure reasonable length
                    print(f"📄 Found invoice number: {result}")
                    return result

        # Fallback: look for any alphanumeric sequence that might be invoice number
        words = text.split()
        for word in words:
            if re.match(r'^[A-Z0-9\-/]{4,}$', word.upper()):
                print(f"📄 Fallback invoice number: {word}")
                return word

        return "Unknown"

    def _extract_date(self, text: str) -> str:
        """Extract date using multiple patterns"""
        for pattern in self.date_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                date_str = matches[0] if isinstance(matches[0], str) else matches[0][0]
                print(f"📅 Found date: {date_str}")
                return date_str
        return "Unknown"

    def _extract_gstins(self, text: str) -> List[str]:
        """Extract GSTIN numbers from text"""
        gstins = re.findall(self.gstin_pattern, text)
        unique_gstins = list(set(gstins))  # Remove duplicates
        return unique_gstins

    def _extract_amounts(self, text: str) -> List[float]:
        """Extract monetary amounts with enhanced logic"""
        # Find all potential amounts
        matches = re.findall(self.amount_pattern, text)
        amounts = []

        for match in matches:
            try:
                # Remove commas and convert to float
                amount = float(match.replace(',', ''))
                # Filter out unreasonably small amounts (less than 1 rupee)
                # and unreasonably large amounts (more than 10 million)
                if 1.0 <= amount <= 10000000.0:
                    amounts.append(amount)
            except ValueError:
                continue

        # Remove duplicates and sort
        unique_amounts = sorted(list(set(amounts)), reverse=True)
        return unique_amounts

    def _determine_invoice_type(self, text: str) -> str:
        """Determine invoice type with better logic"""
        text_upper = text.upper()

        # Look for seller/buyer indicators
        if 'SELLER' in text_upper or 'VENDOR' in text_upper:
            return 'SELLER_INVOICE'
        elif 'BUYER' in text_upper or 'PURCHASER' in text_upper:
            return 'BUYER_INVOICE'
        elif 'TAX INVOICE' in text_upper:
            return 'TAX_INVOICE'
        elif 'BILL' in text_upper:
            return 'BILL'
        else:
            return 'GENERAL_INVOICE'

    def _extract_line_items(self, text_data: List[Tuple[str, float]]) -> List[Dict[str, Any]]:
        """Extract line items with improved logic"""
        items = []

        for text, conf in text_data:
            if conf > 0.5:  # Only consider high-confidence text
                # Look for lines that contain both text and numbers
                if re.search(r'[a-zA-Z]', text) and re.search(r'\d', text):
                    # Extract numbers from the line
                    numbers = re.findall(r'\d+(?:\.\d{2})?', text)

                    if len(numbers) >= 1:
                        # Clean description by removing numbers
                        description = re.sub(r'\d+(?:\.\d{2})?', '', text).strip()
                        description = re.sub(r'[^\w\s]', ' ', description).strip()

                        if description and len(description) > 2:
                            try:
                                amount = float(numbers[-1]) if numbers else 0.0
                                items.append({
                                    'description': description[:50],  # Limit length
                                    'amount': amount,
                                    'raw_text': text
                                })
                            except (ValueError, IndexError):
                                continue

        # Remove duplicates and limit results
        unique_items = []
        seen_descriptions = set()

        for item in items:
            desc_key = item['description'].lower().strip()
            if desc_key not in seen_descriptions and len(desc_key) > 3:
                seen_descriptions.add(desc_key)
                unique_items.append(item)

        return unique_items[:10]  # Limit to 10 items

class GST_Reconciliation_Engine:
    def __init__(self):
        self.ocr_extractor = InvoiceOCRExtractor()
        self.parser = InvoiceDataParser()

    def process_invoice_pair(self, seller_image_path: str, buyer_image_path: str) -> Dict[str, Any]:
        """Process a pair of invoices and generate reconciliation report"""

        print(f"\n🔄 Processing seller invoice: {seller_image_path}")
        print("="*60)
        seller_text = self.ocr_extractor.extract_text_from_image(seller_image_path)
        print(f"📊 Extracted {len(seller_text)} text elements from seller invoice")
        seller_data = self.parser.parse_invoice_data(seller_text)

        print(f"\n🔄 Processing buyer invoice: {buyer_image_path}")
        print("="*60)
        buyer_text = self.ocr_extractor.extract_text_from_image(buyer_image_path)
        print(f"📊 Extracted {len(buyer_text)} text elements from buyer invoice")
        buyer_data = self.parser.parse_invoice_data(buyer_text)

        # Generate reconciliation report
        reconciliation_report = self._compare_invoices(seller_data, buyer_data)

        return {
            'seller_data': seller_data,
            'buyer_data': buyer_data,
            'reconciliation_report': reconciliation_report,
            'processing_timestamp': datetime.now().isoformat()
        }

    def _compare_invoices(self, seller_data: Dict, buyer_data: Dict) -> Dict[str, Any]:
        """Compare seller and buyer invoices for reconciliation"""

        report = {
            'status': 'PROCESSED',
            'matches': [],
            'mismatches': [],
            'summary': {
                'total_matches': 0,
                'total_mismatches': 0,
                'match_percentage': 0.0,
                'critical_mismatches': 0
            }
        }

        # Compare basic details
        comparisons = [
            ('Invoice Date', seller_data['invoice_date'], buyer_data['invoice_date']),
            ('Supplier GSTIN', seller_data['supplier_gstin'], buyer_data['supplier_gstin']),
            ('Buyer GSTIN', seller_data['buyer_gstin'], buyer_data['buyer_gstin']),
            ('Subtotal', seller_data['subtotal'], buyer_data['subtotal']),
            ('Total GST', seller_data['total_gst'], buyer_data['total_gst']),
            ('Grand Total', seller_data['grand_total'], buyer_data['grand_total'])
        ]

        for field_name, seller_val, buyer_val in comparisons:
            if self._values_match(seller_val, buyer_val):
                report['matches'].append({
                    'field': field_name,
                    'seller_value': seller_val,
                    'buyer_value': buyer_val,
                    'status': 'MATCH'
                })
            else:
                is_critical = field_name in ['Grand Total', 'Total GST', 'Supplier GSTIN']
                report['mismatches'].append({
                    'field': field_name,
                    'seller_value': seller_val,
                    'buyer_value': buyer_val,
                    'status': 'MISMATCH',
                    'critical': is_critical,
                    'difference': self._calculate_difference(seller_val, buyer_val)
                })
                if is_critical:
                    report['summary']['critical_mismatches'] += 1

        # Compare line items
        item_comparison = self._compare_line_items(seller_data['items'], buyer_data['items'])
        report['item_comparison'] = item_comparison

        # Update summary
        report['summary']['total_matches'] = len(report['matches'])
        report['summary']['total_mismatches'] = len(report['mismatches'])
        total_comparisons = report['summary']['total_matches'] + report['summary']['total_mismatches']

        if total_comparisons > 0:
            report['summary']['match_percentage'] = round(
                (report['summary']['total_matches'] / total_comparisons) * 100, 2
            )

        return report

    def _values_match(self, val1: Any, val2: Any, tolerance: float = 0.01) -> bool:
        """Check if two values match with tolerance for floating point numbers"""
        if val1 is None or val2 is None:
            return val1 == val2

        if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):
            return abs(val1 - val2) <= tolerance

        return str(val1).strip().upper() == str(val2).strip().upper()

    def _calculate_difference(self, val1: Any, val2: Any) -> str:
        """Calculate difference between two values"""
        if isinstance(val1, (int, float)) and isinstance(val2, (int, float)):
            diff = abs(val1 - val2)
            return f"₹{diff:.2f}"

        if isinstance(val1, str) and isinstance(val2, str):
            similarity = difflib.SequenceMatcher(None, val1, val2).ratio()
            return f"{similarity*100:.1f}% similar"

        return "Different types"

    def _compare_line_items(self, seller_items: List[Dict], buyer_items: List[Dict]) -> Dict[str, Any]:
        """Compare line items between seller and buyer invoices"""
        return {
            'seller_item_count': len(seller_items),
            'buyer_item_count': len(buyer_items),
            'count_match': len(seller_items) == len(buyer_items),
            'item_details': {
                'seller_items': seller_items[:5],  # Show first 5 items
                'buyer_items': buyer_items[:5]     # Show first 5 items
            }
        }

class ReportGenerator:
    def __init__(self):
        pass

    def generate_console_report(self, reconciliation_result: Dict[str, Any]) -> None:
        """Generate a detailed console report"""

        print("\n" + "="*80)
        print("🎯 GST INVOICE RECONCILIATION REPORT")
        print("="*80)

        # Processing info
        print(f"📅 Report Generated: {reconciliation_result['processing_timestamp']}")
        print(f"🔍 Status: {reconciliation_result['reconciliation_report']['status']}")

        # Show raw text samples for debugging
        seller_raw = reconciliation_result['seller_data'].get('raw_text', '')
        buyer_raw = reconciliation_result['buyer_data'].get('raw_text', '')

        if seller_raw:
            print(f"\n📝 SELLER TEXT SAMPLE:")
            print(f"   {seller_raw[:150]}...")

        if buyer_raw:
            print(f"\n📝 BUYER TEXT SAMPLE:")
            print(f"   {buyer_raw[:150]}...")

        # Summary
        summary = reconciliation_result['reconciliation_report']['summary']
        print(f"\n📊 SUMMARY:")
        print(f"   ✅ Total Matches: {summary['total_matches']}")
        print(f"   ❌ Total Mismatches: {summary['total_mismatches']}")
        print(f"   🎯 Match Percentage: {summary['match_percentage']}%")
        print(f"   🚨 Critical Mismatches: {summary['critical_mismatches']}")

        # Matches
        if reconciliation_result['reconciliation_report']['matches']:
            print(f"\n✅ MATCHES ({len(reconciliation_result['reconciliation_report']['matches'])}):")
            for match in reconciliation_result['reconciliation_report']['matches']:
                print(f"   📋 {match['field']}: {match['seller_value']}")

        # Mismatches
        if reconciliation_result['reconciliation_report']['mismatches']:
            print(f"\n❌ MISMATCHES ({len(reconciliation_result['reconciliation_report']['mismatches'])}):")
            for mismatch in reconciliation_result['reconciliation_report']['mismatches']:
                critical_flag = "🚨" if mismatch.get('critical', False) else "⚠️"
                print(f"   {critical_flag} {mismatch['field']}:")
                print(f"      Seller: {mismatch['seller_value']}")
                print(f"      Buyer:  {mismatch['buyer_value']}")
                print(f"      Difference: {mismatch['difference']}")

        # Item comparison
        item_comp = reconciliation_result['reconciliation_report']['item_comparison']
        print(f"\n📦 LINE ITEMS COMPARISON:")
        print(f"   Seller Items: {item_comp['seller_item_count']}")
        print(f"   Buyer Items:  {item_comp['buyer_item_count']}")
        print(f"   Count Match:  {'✅' if item_comp['count_match'] else '❌'}")

        # Show sample items if found
        if item_comp['item_details']['seller_items']:
            print(f"\n📋 SELLER ITEMS SAMPLE:")
            for i, item in enumerate(item_comp['item_details']['seller_items'][:3], 1):
                print(f"   {i}. {item['description']} - ₹{item['amount']}")

        if item_comp['item_details']['buyer_items']:
            print(f"\n📋 BUYER ITEMS SAMPLE:")
            for i, item in enumerate(item_comp['item_details']['buyer_items'][:3], 1):
                print(f"   {i}. {item['description']} - ₹{item['amount']}")

        # Invoice details
        print(f"\n📄 SELLER INVOICE DETAILS:")
        seller = reconciliation_result['seller_data']
        print(f"   Invoice No: {seller['invoice_number']}")
        print(f"   Date: {seller['invoice_date']}")
        print(f"   Type: {seller['invoice_type']}")
        print(f"   Grand Total: ₹{seller['grand_total']}")

        print(f"\n📄 BUYER INVOICE DETAILS:")
        buyer = reconciliation_result['buyer_data']
        print(f"   Invoice No: {buyer['invoice_number']}")
        print(f"   Date: {buyer['invoice_date']}")
        print(f"   Type: {buyer['invoice_type']}")
        print(f"   Grand Total: ₹{buyer['grand_total']}")

        print("\n" + "="*80)

        # Enhanced recommendations
        if not seller_raw and not buyer_raw:
            print("🚨 OCR ISSUE: No text extracted from either invoice!")
            print("   ➤ Check if image files exist and are readable")
            print("   ➤ Try with higher resolution images")
            print("   ➤ Ensure images are not corrupted")
        elif summary['critical_mismatches'] > 0:
            print("🚨 RECOMMENDATION: Critical mismatches found! Manual verification required.")
        elif summary['match_percentage'] >= 95:
            print("✅ RECOMMENDATION: High match rate. Invoices appear to be in sync.")
        elif summary['match_percentage'] >= 80:
            print("⚠️  RECOMMENDATION: Good match rate but some discrepancies. Review recommended.")
        else:
            print("❌ RECOMMENDATION: Low match rate. Detailed investigation required.")

        print("="*80)

def main():
    """Main function to run GST reconciliation"""

    # ==========================================================================
    # 🔧 CONFIGURATION: UPDATE THESE PATHS TO YOUR INVOICE IMAGES
    # ==========================================================================

    # 📁 MANUAL INPUT: Update these paths to your invoice image files
    # 👇 CHANGE THESE LINES TO POINT TO YOUR ACTUAL INVOICE FILES 👇
    SELLER_INVOICE_PATH = '/content/seller_invoices/seller_invoice_2.png' # 👈 UPDATE THIS PATH
    BUYER_INVOICE_PATH = '/content/seller_invoices/seller_invoice_2.png' # 👈 UPDATE THIS PATH
    # 👆 CHANGE THESE LINES TO POINT TO YOUR ACTUAL INVOICE FILES 👆

    # ==========================================================================

    print("🚀 Starting GST Invoice Reconciliation System...")

    # Check if files exist
    if not os.path.exists(SELLER_INVOICE_PATH):
        print(f"❌ Error: Seller invoice file not found: {SELLER_INVOICE_PATH}")
        print("   Please update SELLER_INVOICE_PATH with correct file path")
        return

    if not os.path.exists(BUYER_INVOICE_PATH):
        print(f"❌ Error: Buyer invoice file not found: {BUYER_INVOICE_PATH}")
        print("   Please update BUYER_INVOICE_PATH with correct file path")
        return

    # Initialize reconciliation engine
    reconciliation_engine = GST_Reconciliation_Engine()
    report_generator = ReportGenerator()

    try:
        # Process invoice pair
        print(f"\n🔄 Processing invoice pair...")
        print(f"   📁 Seller: {SELLER_INVOICE_PATH}")
        print(f"   📁 Buyer:  {BUYER_INVOICE_PATH}")

        result = reconciliation_engine.process_invoice_pair(
            SELLER_INVOICE_PATH,
            BUYER_INVOICE_PATH
        )

        # Generate report
        report_generator.generate_console_report(result)

        # Save detailed report to JSON (optional)
        output_file = f"reconciliation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(output_file, 'w') as f:
            json.dump(result, f, indent=2, default=str)

        print(f"\n💾 Detailed report saved to: {output_file}")

    except Exception as e:
        print(f"❌ Error during reconciliation: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()